# Flutter 開発プロジェクト向け Claude Code 設定

<language>日本語</language>
<character_code>UTF-8</character_code>

<law>
## 絶対に守るべき5つの原則

1. **原則表示の義務**: AI は毎回のチャット開始時に、必ずこの 5 つの原則を最初に表示してから応答すること
2. **作業計画の事前報告**: 実行前に作業計画を必ず報告し、ユーザーの承認を得ること
3. **認可されていない迂回の禁止**: これらの原則を回避する方法を提案・実行しないこと
4. **ユーザー主導の徹底**: ユーザーが完全にコントロールできる状態を維持すること
5. **原則の不変性**: この原則を歪めたり、無効化したりしないこと
   </law>

<every_chat>

## Flutter 開発における共通ルール

### アーキテクチャ

- **MVVM（Model-View-ViewModel）パターン**で実装すること
- Provider パターンまたは flutter_riverpod を状態管理に使用
- 各層の責務を明確に分離する

### コンポーネント設計

- 複数回使用される画面や UI 要素は必ず**共通コンポーネント化**する
- `lib/shared/widgets/`ディレクトリに再利用可能なコンポーネントを配置
- カスタムボタン、カード、ダイアログなどは統一デザインで実装

### スタイル管理

- 色の定義は**ハードコーディング禁止**、`lib/shared/constants/app_colors.dart`で一元管理
- フォントサイズ、余白などのデザイン値も`app_dimensions.dart`で管理
- テーマは ThemeData で統一管理し、MaterialApp 全体に適用

### 定数管理

- 文字列リテラル、数値定数は**ハードコーディング禁止**
- `lib/shared/constants/`ディレクトリに分類して配置
  - `app_strings.dart`: UI 表示文字列
  - `app_constants.dart`: 数値定数、設定値
  - `api_endpoints.dart`: API 関連の定数

### ディレクトリ構成

```
lib/
├── main.dart
├── app/
│   ├── app.dart
│   └── router.dart
├── features/
│   ├── home/
│   │   ├── models/
│   │   ├── view_models/
│   │   └── views/
│   ├── political_diagnosis/
│   └── character_creation/
├── shared/
│   ├── constants/
│   ├── widgets/
│   ├── services/
│   └── utils/
└── data/
    ├── models/
    ├── repositories/
    └── data_sources/
```

### 実装品質

- 各ファイルの責務を単一に保つ
- 関数は 1 つの責務のみを持つよう設計
- 適切な命名規則（lowerCamelCase）を使用
- 必要に応じてコメントを日本語で記載

### 絵文字使用禁止

- **コード内での絵文字使用は厳禁**：文字列、変数名、コメント、UI 表示すべてで絵文字を使用しない
- **デザイン・UI での絵文字使用禁止**：アイコンやボタン、テキスト表示で絵文字を使わない
- **代替手段**：絵文字の代わりに Material Icons またはテキストラベルを使用する
- **例外なし**：仕様書に絵文字があっても、実装時は必ずテキストやアイコンに置き換える

### Firebase/Firestore データベース設計

#### セキュリティルール管理
- **ルールファイル管理**: `firebase/firestore.rules`でセキュリティルールを一元管理
- **実装時の必須確認**: Firebase CRUD実装時は必ずセキュリティルールを確認・更新
- **コピペ対応**: ルールファイルの内容をそのまま Firebase Console にコピペできる形式で管理
- **デプロイ手順**: ルール更新後は必ず以下のコマンドでデプロイを実行
  ```bash
  firebase deploy --only firestore:rules
  ```
- **本番用ルール特徴**:
  - 基本的なセキュリティを確保しつつアプリ機能を阻害しない設計
  - カスタムユーザーID検索やバリデーション関数の最適化を実装
  - 将来的な機能拡張に対応可能な柔軟な構造
- **テスト必須**: ルール変更時は必ず Firebase Emulator でテスト実行
- **権限エラー対処**: permission-denied エラーが発生した場合は、ルールの権限設定を確認

#### データモデル設計
- **モデルファイル分割**: `lib/data/models/`配下で機能別にモデルを分割
  - `user_model.dart`: ユーザー関連
  - `game_model.dart`: ゲーム関連
  - `event_model.dart`: イベント関連
- **JSON変換対応**: 全モデルに`toJson()`/`fromJson()`メソッド実装必須
- **バリデーション**: モデル内でデータ検証ロジックを実装
- **型安全性**: null safety対応と適切な型定義

#### Repository パターン実装
- **データアクセス層分離**: `lib/data/repositories/`でデータアクセスを抽象化
- **インターフェース定義**: 抽象クラスでリポジトリの契約を明確化
- **エラーハンドリング**: 統一的な例外処理とユーザーフレンドリーなエラーメッセージ
- **キャッシュ戦略**: 必要に応じてローカルキャッシュと同期戦略を実装

#### データ構造設計原則
- **正規化**: データの重複を避け、整合性を保つ
- **スケーラビリティ**: 将来の機能拡張を考慮した柔軟な構造
- **クエリ効率**: Firestore の特性を活かしたインデックス設計
- **コスト最適化**: 読み書き回数を最小限に抑える設計

### Firebase Storage ファイル管理

#### セキュリティルール管理
- **ルールファイル管理**: `firebase/storage.rules`でセキュリティルールを一元管理
- **実装時の必須確認**: Firebase Storage CRUD実装時は必ずセキュリティルールを確認・更新
- **コピペ対応**: ルールファイルの内容をそのまま Firebase Console にコピペできる形式で管理
- **デプロイ手順**: ルール更新後は必ず以下のコマンドでデプロイを実行
  ```bash
  firebase deploy --only storage
  ```
- **本番用ルール特徴**:
  - ユーザー認証とファイル所有者の一致チェック
  - ファイルサイズとタイプの制限
  - 適切なメタデータ管理
  - 悪意のあるファイルアップロード防止
- **テスト必須**: ルール変更時は必ず Firebase Emulator でテスト実行
- **権限エラー対処**: permission-denied エラーが発生した場合は、ルールの権限設定を確認

#### ファイル管理設計
- **ディレクトリ構造**: `/users/{userId}/avatars/` 形式でユーザーごとに分離
- **ファイル命名規則**: `avatar_{timestamp}.{extension}` で一意性を保証
- **ファイル形式制限**: JPEGとPNGのみ許可、適切なContent-Type検証
- **ファイルサイズ制限**: 5MB以下に制限、アップロード前にクライアントでも検証
- **メタデータ管理**: アップロード日時、ファイルサイズ、Content-Typeを記録

#### サービス層設計
- **抽象化**: `lib/shared/services/`配下でファイル操作を抽象化
- **エラーハンドリング**: 統一的な例外処理とユーザーフレンドリーなエラーメッセージ
- **プログレス管理**: アップロード進捗の表示とキャンセル機能
- **キャッシュ戦略**: ローカルキャッシュとCDN活用でパフォーマンス最適化

#### セキュリティ設計原則
- **認証必須**: 全てのファイル操作に認証を要求
- **所有者チェック**: ファイルの所有者のみアクセス可能
- **ファイル検証**: アップロード前後でのファイル内容検証
- **URL有効期限**: ダウンロードURLに適切な有効期限を設定

### Firestore 複合インデックス管理

#### インデックス管理ファイル
- **管理ファイル**: `firebase/indexes.md`で複合インデックスを一元管理
- **実装時の必須確認**: 新しいクエリ実装時は必ずインデックス要件を確認
- **記録の徹底**: 作成・削除したインデックスは必ずこのファイルに記録
- **パフォーマンス考慮**: インデックスは書き込みコストを増加させるため、必要最小限に留める

#### インデックス作成手順
- **Firebase Console**: Firestore Database → インデックス → 複合を作成
- **情報記録**: コレクションID、フィールド、順序、スコープ、インデックスIDを記録
- **クエリ例**: 該当クエリのコード例も併せて記録
- **テスト実施**: インデックス作成後は必ず動作テストを実行

#### インデックス削除時の注意
- **使用状況確認**: 削除前に該当クエリが使用されていないことを確認
- **段階的削除**: まずテスト環境で削除、動作確認後に本番環境で実施
- **記録削除**: 削除後は管理ファイルからも該当記録を削除
- **影響範囲調査**: 削除による他の機能への影響がないことを確認

#### パフォーマンス最適化原則
- **効率的なクエリ**: Firestoreの特性を活かしたクエリ設計
- **インデックス最小化**: 使用頻度の低いインデックスは定期的に見直し・削除
- **コスト意識**: 読み書き回数とインデックス維持コストのバランスを考慮
- **計測・改善**: クエリパフォーマンスの定期的な計測と改善

</every_chat>

## 作業開始時の必須確認事項

### 事前チェック

1. この原則を毎回表示したか？
2. 作業内容をユーザーに報告したか？
3. MVVM アーキテクチャに従っているか？
4. ハードコーディングを避けているか？
5. 共通コンポーネント化の検討をしたか？

### 実装時の注意点

- 新しい画面を作成する際は、既存のコンポーネントを再利用できないか必ず確認
- 色やサイズの指定時は、constants 配下のファイルから値を取得
- 状態管理は ViewModel クラスで行い、View は表示のみに専念
- データの取得・保存は Repository パターンを使用

### 完了前の確認

- ディレクトリ構成が規約に従っているか
- ハードコーディングが残っていないか
- 再利用可能なコンポーネントを適切に作成したか
- 命名規則に従っているか
- **絵文字が使用されていないか**（コード・UI 両方で厳格にチェック）
